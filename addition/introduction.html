<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>在Android上像SpringMVC一样做Web开发</title> <link rel="stylesheet" href="./stackedit.css"/> <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png"> <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon"> </head> <body class="stackedit"> <div class="stackedit__html"><h1 id="在android上像springmvc一样做web开发">在Android上像SpringMVC一样做Web开发</h1> <p>一部分Android开发者看到这个标题时可能有点疑惑，SpringMVC不是用来做JavaWeb开发的吗？难道被移植到Android上来了？答案是否定的，因为SpringMVC是基于Servlet的，在Android上开发一个支持Servlet的容器（Tomcat、JBoss）可不简单，所以我们是在Android上开发了一套全新的WebServer + WebFramework。</p> <p>AndServer2.0基于编译时注解实现了SpringMVC的大部分注解Api，其Request的分发流程也基本和SpringMVC一致，与SpringMVC最大的不同是SpringMVC基于运行时注解，并且SpringMVC提供的功能更多更强大。不过AndServer提供的功能在Android上来做服务端开发是完全足够的。</p> <p>看到这里读者朋友应该知道了，AndServer2.0是使用注解开发Web程序的，为了有个更直观的了解，我们先看一个模拟用户登录的Http Api：</p> <pre class=" language-java"><code class="prism  language-java"><span class="token annotation punctuation">@RestController</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/login"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> String <span class="token function">login</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"account"</span><span class="token punctuation">)</span> String account<span class="token punctuation">,</span>
        <span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span> String password<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token string">"Successful"</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token string">"Failed"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <p>假设服务端的Address是<code>192.168.1.11</code>，监听的端口是<code>8080</code>，那么通过<code>http://192.168.1.11:8080/login</code>就可以访问该登录Http Api了。</p> <p>感兴趣的读者可以帮我们做一下Code Review：<br> <a href="https://github.com/yanzhenjie/AndServer">https://github.com/yanzhenjie/AndServer</a></p> <p>下文将依次介绍以下三点：</p> <ol> <li>系统层架构蓝图</li> <li>应用层架构蓝图</li> <li>使用示例</li> </ol> <h2 id="系统层架构蓝图">1. 系统层架构蓝图</h2> <p>我们都知道Http是根据Http协议使用Socket做了连接属性、数据格式、交互逻辑方面的包装，我们来<strong>模拟</strong>一段服务端启动Server的代码：</p> <pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">startServer</span><span class="token punctuation">(</span>String address<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    InetAddress inetAddress <span class="token operator">=</span> InetAddress<span class="token punctuation">.</span><span class="token function">getByName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ServerSocket serverSocket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> inetAddress<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Socket socket <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        HttpConnection connection <span class="token operator">=</span> HttpParser<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">;</span>
        HttpThead thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HttpThread</span><span class="token punctuation">(</span>connection<span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <p><code>ServerSocket</code>监听了某个端口，当有<code>Socket</code>连接上来的时候去把这个<code>Socket</code>解析为<code>HttpConnection</code>，可想而知，作为服务端程序，<code>HttpConnection</code>至少包涵了<code>Request</code>和<code>Response</code>对象：</p> <pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpConnection</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> Request mRequest<span class="token punctuation">;</span>
    <span class="token keyword">private</span> Response mResponse<span class="token punctuation">;</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> <p>紧接着启动了一个线程去处理这个<code>Request</code>，怎么处理这个<code>Request</code>是一个WebFramework的核心，假设我们有一个类叫做<code>HttpDispatcher</code>，负责派发请求到Html File或者Java Method处理：</p> <pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpDispatcher</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dispath</span><span class="token punctuation">(</span>Request request<span class="token punctuation">,</span> Response response<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> <p><code>HttpThead</code>只需要负责调用<code>HttpDispatcher#diaptch()</code>即可，到这里就比较清晰了，只需要<code>HttpDispatcher</code>把当前<code>Request</code>派发到对应的Html File或者Java Method处理就可以了。</p> <p>这就是一个简单的WebServer的蓝图，我们根据设想画出了系统层架构图：</p> <p><img src="../images/system_structure.svg" alt="系统层架构图"></p> <p>系统层运行时流程图：</p> <p><img src="../images/system_flow_chat.gif" alt="系统层流程图"></p> <p>上图中，<code>Handler</code>表示处理请求的操作手柄，可能是Html File或者Java Method。值得高兴的一点是，在我们迭代了几个版本后，发现Apache组织提供了上述蓝图中的<code>HttpParser</code>层，因此为了稳定性和节省人力我们已经替换该层为Apache的实现。</p> <h2 id="应用层架构蓝图">2. 应用层架构蓝图</h2> <p>应用层就是上文中提到的WebFramework的核心，也就是上一个小节流程图的<code>Framework</code>层，包括了Session的处理、Cookie的处理、Cache的处理等。</p> <p>接着上文，<code>HttpDispatcher</code>需要把当前<code>Request</code>派发到对应的Html File或者Java Method处理，而<code>Handler</code>代表了Html File或者Java Method，那么因为此二者区别极大，因此我们想到了使用<code>Adapter</code>模式，所以有了一个抽象类<code>RequestHandler</code>：</p> <pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">RequestHandler</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>Request request<span class="token punctuation">,</span> Response response<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <p>所以必须得有一个<code>HandlerAdapter</code>去做<code>Handler</code>适配：</p> <pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HandlerAdapter</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> RequestHandler <span class="token function">getHandler</span><span class="token punctuation">(</span>Request request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <p>因为Html File和Java Method的返回值又是大相径庭，因为返回值是输出到客户端展示的，所以我们把返回值抽象为<code>View</code>：</p> <pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">View</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> Object <span class="token function">output</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <p>因为<code>View</code>是返回值，没有具体的交互了，所以不适用<code>Adapter</code>模式了，因此我们必须有一个处理返回值的机制，把处理返回值的机制叫做<code>ViewResolver</code>：</p> <pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ViewResolver</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">resolver</span><span class="token punctuation">(</span>View view<span class="token punctuation">,</span> Request request<span class="token punctuation">,</span> Response response<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <p>这就是一个简单的WebFramework的蓝图，我们根据设想画出了应用层架构图：</p> <p><img src="../images/framework_structure.svg" alt="应用层架构图"></p> <p>应用层运行时流程图：</p> <p><img src="../images/framework_flow_chat.gif" alt="应用层流程图"></p> <p>上图中，<code>Interceptor</code>表示拦截请求的拦截器，比如可以做一些不允许没登录或者没权限的请求进入的工作。<code>ExceptionResolver</code>表示全局异常处理器，比如某个Api发生了异常，会转到<code>ExceptionResolver</code>中处理，而不至于当前请求不响应或者响应了不想被客户端看到的消息。</p> <blockquote> <p>另外需要补充的是，上文中提到的都是粗略的设计，中间还有一些细节，例如Session的处理、Cookie的处理、缓存的处理等都未提到，其中任何一个知识点单独拿出来都可以写一篇文章，由于篇幅关系这里不做详细介绍。</p> </blockquote> <p>架构设计和流程到此就都介绍完了，有兴趣的开发者也可以自己实现一下，下面我们将简单介绍一下AndServer的使用。</p> <h2 id="使用示例">3. 使用示例</h2> <p>AndServer对于方便使用的理念是：只需要添加注解即可，不需要再做额外的配置。所以除了像文章开头那样用注解写好Api之外，只需要指定监听端口启动服务器就可以了。</p> <blockquote> <p>与读者做个约定，下文中服务器Address都是<code>192.168.1.11</code>，监听的端口是<code>8080</code>。</p> </blockquote> <h3 id="网站部署示例">3.1. 网站部署示例</h3> <p>我们先来部署一个位于Assets中<code>/web</code>下的网站：</p> <pre class=" language-java"><code class="prism  language-java"><span class="token annotation punctuation">@Website</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InternalWebsite</span> <span class="token keyword">extends</span> <span class="token class-name">AssetsWebsite</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token function">InternalWebsite</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token string">"/web"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <p>因此SD的文件可以删除也可以增加，想做到热插拔，就署位于SD卡的网站：</p> <pre class=" language-java"><code class="prism  language-java"><span class="token annotation punctuation">@Website</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InternalWebsite</span> <span class="token keyword">extends</span> <span class="token class-name">StorageWebsite</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token function">InternalWebsite</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token string">"/sdcard/AndServer/web"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <p>如上所示，开发者只需要将网站所在的路径告诉<code>AndServer</code>，并添加<code>Website</code>注解即可，该网站的Html、CSS、JS、其它文件都可以被访问，例如<code>/web</code>目录下有一个<code>index.html</code>文件，那么访问地址就是<code>http://192.168.1.11:8080/</code>或者<code>http://192.168.1.11:8080/index.html</code>。</p> <h3 id="http-api开发示例">3.2. Http Api开发示例</h3> <p>在文章开头我们看了一个模拟用户的Http Api，下面我们增加一个模拟获取用户信息的Api：</p> <pre class=" language-java"><code class="prism  language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@RestController</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/login"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> String <span class="token function">login</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"account"</span><span class="token punctuation">)</span> String account<span class="token punctuation">,</span>
        <span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span> String password<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token string">"Successful"</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token string">"Failed"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/info/{userId}"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> User <span class="token function">info</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"userId"</span><span class="token punctuation">)</span> String userId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        User user <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> user<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <p>于是我们得到两个地址：</p> <pre class=" language-text"><code class="prism  language-text">POST http://192.168.1.11:8080/user/login
GET  http://192.168.1.11:8080/user/info/uid_001
</code></pre> <h3 id="启动服务器">3.3. 启动服务器</h3> <pre class=" language-java"><code class="prism  language-java">AndServer<span class="token punctuation">.</span><span class="token function">serverBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">inetAddress</span><span class="token punctuation">(</span>NetUtils<span class="token punctuation">.</span><span class="token function">getLocalIPAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">port</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">timeout</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <p>如上所示只需要指定要监听的服务端地址和端口，启动服务器即可。</p> <p>本人到此就结束，由于篇幅关系，介绍的比较粗略，有兴趣的开发者可以看看项目使用文档：<br> <a href="https://www.yanzhenjie.com/AndServer">https://www.yanzhenjie.com/AndServer</a></p> </div> </body> </html>